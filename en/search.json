[
  {
    "objectID": "index.en.html",
    "href": "index.en.html",
    "title": "Introdução à acessibilidade urbana",
    "section": "",
    "text": "Accessibility is the ease with which people can reach places and opportunities such as jobs, health and education services, cultural activities, green areas, etc. The accessibility conditions of a city or neighborhood depend on the efficiency and connectivity of the transport network and on the proximity between people and activities. The topic of accessibility has been receiving increasing attention from transportation agencies, funding institutions, decision makers and researchers in the fields of urban and transport planning (Papa et al. 2015; Boisjoly and El-Geneidy 2017). In the last few years, we have seen a growing number of scientific papers (Miller 2018; van Wee 2021) and books (Levine, Grengs, and Merlin 2019; Levinson and King 2020) that deepens our understanding of urban accessibility issues. However, there are currently no books or articles that serve simultaneously as an introductory material to the subject and as a practical manual to teach computational methods to calculate and analyze accessibility data. The lack of this type of material helps explain, at least in part, why several transportation agencies and analysts still face challenges in incorporating accessibility issues and indicators into the day-to-day planning and research practice (Silva et al. 2017; Büttner 2021).\nThe aim of this book is to equip its readers with the fundamental concepts, the data analysis skills and processing tools needed to perform urban accessibility analyses and assess the impact of transportation projects and policies. The book was written keeping in mind some of the problems faced by public managers, policy makers, students and researchers working on urban and transportation planning. Hence, the book has a practical character. All the material in the book is presented with reproducible examples using open data sets and the R programming language."
  },
  {
    "objectID": "index.en.html#book-organization",
    "href": "index.en.html#book-organization",
    "title": "Introdução à acessibilidade urbana",
    "section": "Book organization",
    "text": "Book organization\nThis book is divided into 5 sections:\n\n\n\n\n\nSection\nDescription\n\n\n\n\n1: Introduction to urban accessibility\nThe first section presents the concept of urban accessibility, clarifies the differences between accessibility and mobility, and presents the main indicators found in the literature to measure urban accessibility.\n\n\n2: Calculating accessibility\nThe second section teaches how to calculate urban accessibility estimates in R using the {r5r} and {accessibility} packages and open data, and how to visualize results with maps and charts.\n\n\n3: Public transport data\nThe third section presents what is the GTFS specification of public transport data, and shows how to work and analyze GTFS data using the {gtfstools} package.\n\n\n4: Impact assessment of transport projects\nThe fourth section brings a case study to illustrate how the combined knowledge of previous chapters can be used to assess the impact of transportation policies on urban accessibility conditions.\n\n\n5: Access to Opportunities Project Data\nFinally, the fifth section shows how to download, analyze and visualize the data of the Access to Opportunities Project (AOP) to analyze the spatial and socioeconomic distribution of access to opportunities in Brazilian cities."
  },
  {
    "objectID": "index.en.html#reproducing-the-book-in-your-computer-locally",
    "href": "index.en.html#reproducing-the-book-in-your-computer-locally",
    "title": "Introdução à acessibilidade urbana",
    "section": "Reproducing the book in your computer locally",
    "text": "Reproducing the book in your computer locally\nTo knit the book locally, you must first download its source-code . This can be done with git or manually by clicking on the following link: https://github.com/ipeaGIT/intro_access_book/archive/refs/heads/main.zip. In case you choose the second approach, you must also unzip the contents of the ZIP file to a new folder.\n\n\n\n\n\n\nThis book was written and published with the Quarto publishing system. All of the code used in the preparation and publication of this book can be found in this repository.\n\n\n\nTo render the book locally, you must have Quarto installed on your computer. Reproducing the code of chapters requires the use of the {renv} R package, which manages the book’s dependencies.\nAfter the book dependencies are installed, you can run the book source code. Chapters are numerically ordered in files in .qmd format. To run all chapters at once, use one of the following commands:\nquarto::quarto_preview()\n\nquarto::quarto_render()\nFor more details on how to install the book dependencies and run their content locally, please see the installation instructions in the book repository."
  },
  {
    "objectID": "index.en.html#running-the-book-examples-in-the-cloud-with-binder",
    "href": "index.en.html#running-the-book-examples-in-the-cloud-with-binder",
    "title": "Introdução à acessibilidade urbana",
    "section": "Running the book examples in the cloud with binder",
    "text": "Running the book examples in the cloud with binder\nA binder is a tool that allows one to run code in the cloud on a browser, such as Chrome and Firefox. The book code can be run using a server published by mybinder. To run this book on Binder, click the icon below: after a few moments, an RStudio Cloud session will start running on your browser. This session includes all the files and data needed to run the book code.\n\n\n\nBinder\n\n\nPlease note that mybinder sessions are limited to 2 GB of RAM. This restriction can prevent Chapter 6 from running properly. If you use binder, we suggest that you do not attempt to render the entire book with the Quarto, as shown above."
  },
  {
    "objectID": "index.en.html#license",
    "href": "index.en.html#license",
    "title": "Introdução à acessibilidade urbana",
    "section": "License",
    "text": "License\n The material in this book may be reproduced and displayed for educational or informational purposes, provided credit is given to the original authors and the original work is cited. This book can be shared on websites and free and open online repositories only it is made clear to users the terms of use of this material and who the copyright holder is, the Institute for Applied Economic Research (Ipea). Any commercial or for-profit use is prohibited. The creation of derivative works is prohibited. This license is based on studies about the Brazilian Copyright Law (Law 9.610/1998)."
  },
  {
    "objectID": "index.en.html#how-to-cite-the-book",
    "href": "index.en.html#how-to-cite-the-book",
    "title": "Introdução à acessibilidade urbana",
    "section": "How to cite the book",
    "text": "How to cite the book\nIf you use the material in this book, please cite the book using the following reference:\n\nPereira, Rafael H. M. & Herszenhut, Daniel. (2023) Introduction to urban accessibility a practical guide in R. Ipea - Institute of Applied Economic Research."
  },
  {
    "objectID": "index.en.html#acknowledgements",
    "href": "index.en.html#acknowledgements",
    "title": "Introdução à acessibilidade urbana",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThis book was written under a partnership between the Institute for Applied Economic Research (Ipea) and the Secretariat of Mobility and Regional and Urban Development (SMDRU) of the Ministry of Regional Development (MDR) of the Brazilian federal government. The authors are grateful for the comments and suggestions from Lucas Mation. The authors would also like to thank the contributions of Anna Grigolon, Benjamin Büttner and Aaron Nichols for proofreading the English version of the book.\n\n\n\n\nBoisjoly, Geneviève, and Ahmed M. El-Geneidy. 2017. “How to Get There? A Critical Assessment of Accessibility Objectives and Indicators in Metropolitan Transportation Plans.” Transport Policy 55 (April): 38–50. https://doi.org/10.1016/j.tranpol.2016.12.011.\n\n\nBüttner, Benjamin. 2021. “Accessibility Tools for Transport Policy and Planning.” In International Encyclopedia of Transportation, edited by Roger Vickerman, 83–86. Oxford: Elsevier. https://doi.org/10.1016/B978-0-08-102671-7.10618-9.\n\n\nLevine, Jonathan, Joe Grengs, and Louis A. Merlin. 2019. From Mobility to Accessibility: Transforming Urban Transportation and Land-Use Planning. Cornell University Press.\n\n\nLevinson, David, and David King. 2020. Transport Access Manual: A Guide for Measuring Connection Between People and Places. Committee of the Transport Access Manual, University of Sydney.\n\n\nMiller, Eric J. 2018. “Accessibility: Measurement and Application in Transportation Planning.” Transport Reviews 38 (5): 551–55. https://doi.org/10.1080/01441647.2018.1492778.\n\n\nPapa, Enrica, Cecilia Silva, Marco Te Brömmelstroet, and Angela Hull. 2015. “Accessibility Instruments for Planning Practice: A Review of European Experiences.” Journal of Transport and Land Use, June. https://doi.org/10.5198/jtlu.2015.585.\n\n\nSilva, Cecília, Luca Bertolini, Marco te Brömmelstroet, Dimitris Milakis, and Enrica Papa. 2017. “Accessibility Instruments in Planning Practice: Bridging the Implementation Gap.” Transport Policy 53 (January): 135–45. https://doi.org/10.1016/j.tranpol.2016.09.006.\n\n\nvan Wee, Bert. 2021. “Transport Modes and Accessibility.” In International Encyclopedia of Transportation, edited by Roger Vickerman, 32–37. Oxford: Elsevier. https://doi.org/10.1016/B978-0-08-102671-7.10402-6."
  },
  {
    "objectID": "s1_intro.en.html#teste-2",
    "href": "s1_intro.en.html#teste-2",
    "title": "Teste",
    "section": "Teste 2",
    "text": "Teste 2"
  },
  {
    "objectID": "1_conceito.en.html",
    "href": "1_conceito.en.html",
    "title": "Introdução à acessibilidade urbana",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "2_indicadores.en.html",
    "href": "2_indicadores.en.html",
    "title": "Introdução à acessibilidade urbana",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "s2_calculo.en.html",
    "href": "s2_calculo.en.html",
    "title": "Introdução à acessibilidade urbana",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "3_calculando_acesso.en.html",
    "href": "3_calculando_acesso.en.html",
    "title": "Introdução à acessibilidade urbana",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "s3_dados_tp.en.html",
    "href": "s3_dados_tp.en.html",
    "title": "Introdução à acessibilidade urbana",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "4_dados_gtfs.en.html#gtfs-structure",
    "href": "4_dados_gtfs.en.html#gtfs-structure",
    "title": "4  GTFS data",
    "section": "4.1 GTFS structure",
    "text": "4.1 GTFS structure\nFiles in the GTFS Schedule format (from this point onwards referred to as GTFS) are also known as feeds1. A feed is nothing more than a compressed .zip file that contains a set of tables, saved in .txt, describing some aspects of the public transport network (stops/stations location, trip frequency, itineraries paths, etc). As in a relational database, tables in a feed have key columns that allow you to link information described in one table to the data described in another one. A sample of the GTFS scheme is presented in Figure 4.1, which shows some of the key tables that make up the specification and highlights how they relate to each other.\n\n\n\n\n\nFigure 4.1: GTFS format scheme. Source - Pereira, Andrade, and Vieira (2022)\n\n\n\n\nOverall, 22 tables make up the GTFS format2. Some of them, however, don’t need to be present to consider a feed valid and are, therefore, optional. The specification classifies the presence of a table into the following categories: required, optional and conditionally required (when the presence depends on the existence of a particular table, column or value). For simplicity, in this book we will consider only the first two categories and make sure to comment about the presence condition of a table whenever appropriate. Using our simplified convention, tables are classified as follows:\n\nRequired: agency.txt, stops.txt, routes.txt, trips.txt, stop_times.txt, calendar.txt.\nOptional: calendar_dates.txt, fare_attributes.txt, fare_rules.txt, fare_products.txt, fare_leg_rules.txt, fare_transfer_rules.txt, areas.txt, stop_areas.txt, shapes.txt, frequencies.txt, transfers.txt, pathways.txt, levels.txt, translations.txt, feed_info.txt, attributions.txt.\n\nThroughout this section, we’ll learn about the basic structure of a GTFS file and its tables. Thus, we will look only at the required tables and the optional tables most often used by producers and consumers of these files. For more information on the tables and columns not covered in this section, please check the official specification.\nIn this demonstration, we use a subset of a feed describing the public transport network of São Paulo, Brazil, produced by SPTrans3 and downloaded in October 2019. The feed contains the six required tables plus two widely used optional tables, shapes.txt and frequencies.txt, enabling a good overview of the GTFS format.\n\n\n\n\n4.1.1 agency.txt\nFile used to list the transport operators/agencies running the system described by the GTFS file. Although the term agency is used instead of operators, it is up to the feed producer to choose which institutions will be listed in the table.\nFor example, multiple bus companies operate in a given location, but all schedule and fare planning is carried out by a single institution, either a transport agency or a specific public entity. This institution is also understood by the transit users as the system operator. In this case, we should list the institution responsible for planning the system in the table.\nNow imagine a scenario in which a local public transport agency transfers the responsibility of operating a multimodal system to several companies (through concessions, for example). Each one of these companies is responsible for planning the schedules and fares of trips/routes they operate, provided that certain pre-established parameters are followed. In this case, we should list the operators in the table, not the public transportation agency.\nTable 4.1 shows the agency.txt file of SPTrans’ feed. We can see that the feed producers decided to list the company itself in the table, not the companies that operate the buses and the subway in the city.\n\n\n\n\nTable 4.1: agency.txt example\n\n\n\n\n\n\n\n\n\nagency_id\nagency_name\nagency_url\nagency_timezone\nagency_lang\n\n\n\n\n1\nSPTRANS\nhttp://www.sptrans.com.br/?versao=011019\nAmerica/Sao_Paulo\npt\n\n\n\n\n\n\nIt’s important to note that, although we are presenting agency.txt in table format, the file should be formatted as a .csv file. That is, the values of each cell must be separated by commas, and the contents of each table row must be listed in a different row. The table above, for example, is internally formatted as follows:\n\n\nagency_id,agency_name,agency_url,agency_timezone,agency_lang\n1,SPTRANS,http://www.sptrans.com.br/?versao=011019,America/Sao_Paulo,pt \n\n\nFor the sake of communicability and interpretability, we will always present the examples as tables. It is important to keep in mind, however, that these tables are internally structured as shown above.\n\n\n4.1.2 stops.txt\nFile used to describe the public transport stops in the system. The points listed in this file may reference simpler stops (such as bus stops), stations, platforms, station entrances and exits, etc. Table 4.2 shows the stops.txt of SPTrans’ feed.\n\n\n\n\nTable 4.2: stops.txt example\n\n\n\n\n\n\n\n\n\nstop_id\nstop_name\nstop_desc\nstop_lat\nstop_lon\n\n\n\n\n706325\nParada 14 Bis B/C\nViad. Dr. Plínio De Queiroz, 901\n-23.55593\n-46.65011\n\n\n810602\nR. Sta. Rita, 56\nRef.: R. Bresser / R. João Boemer\n-23.53337\n-46.61229\n\n\n910776\nAv. Do Estado, 5854\nRef.: Rua Dona Ana Néri\n-23.55896\n-46.61520\n\n\n1010092\nParada Caetano Pinto\nAv. Rangel Pestana, 1249 Ref.: Rua Caetano Pinto/rua Prof. Batista De Andrade\n-23.54615\n-46.62218\n\n\n1010093\nParada Piratininga\nAv. Rangel Pestana, 1479 Ref.: Rua Monsenhor Andrade\n-23.54509\n-46.62006\n\n\n1010099\nR. Xavantes, 612\nRef.: Rua Joli\n-23.53545\n-46.61368\n\n\n\n\n\n\nThe columns stop_id and stop_name identify each stop, but fulfill different roles. The purpose of stop_id is to identify relationships between this table and others that compose the specification (as we will later see in the stop_times.txt file, for example). stop_name, however, serves as an identifier that should be easily recognized by the passengers, thus usually assuming values of station names, points of interest names or addresses (as in the case of SPTrans’ feed).\nThe stop_desc column, present in SPTrans’ feed, is optional and allows feed producers to add a description of each stop and its surroundings. Finally, stop_lat and stop_lon associate each stop to a point in space with its latitude and longitude geographic coordinates.\nTwo of the optional columns not present in this stops.txt table are location_type and parent_station. location_type is used to indicate the type of location that each point refers to. When not explicitly set, all points are interpreted as public transport stops, but distinct values can be used to distinguish a stop (location_type = 0) from a station (location_type = 1) or a boarding area (location_type = 2), for example. The parent_station column, on the other hand, is used to describe hierarchical relationships between two points. When describing a boarding area, for example, the feed producer must list the stop/platform that this area refers to, and when describing a stop/platform the producer can optionally list the station that it belongs to.\n\n\n4.1.3 routes.txt\nFile used to describe the public transport routes operated in the system, including the transport modes used in each one of them. Table 4.3 shows the routes.txt of SPTrans’ feed.\n\n\n\n\nTable 4.3: routes.txt example\n\n\n\n\n\n\n\n\n\nroute_id\nagency_id\nroute_short_name\nroute_long_name\nroute_type\n\n\n\n\nCPTM L07\n1\nCPTM L07\nJUNDIAI - LUZ\n2\n\n\nCPTM L08\n1\nCPTM L08\nAMADOR BUENO - JULIO PRESTES\n2\n\n\nCPTM L09\n1\nCPTM L09\nGRAJAU - OSASCO\n2\n\n\nCPTM L10\n1\nCPTM L10\nRIO GRANDE DA SERRA - BRÁS\n2\n\n\nCPTM L11\n1\nCPTM L11\nESTUDANTES - LUZ\n2\n\n\nCPTM L12\n1\nCPTM L12\nCALMON VIANA - BRAS\n2\n\n\n\n\n\n\nAs in the case of stops.txt, the routes.txt table also includes different columns to distinguish between the identifier of each route (route_id) and their names. In this case, however, there are two distinct name columns: route_short_name and route_long_name. The first refers to the name of the route usually used by passengers on their daily routine, while the second tends to be a more descriptive name. SPTrans, for example, chose to highlight the start and endpoints of each route in this column. We can also note that the same values are repeated in both route_id and route_short_name, which is neither required nor forbidden - in this case, the feed producer decided that the route names could satisfactorily work as identifiers because they are reasonably short and unique.\nThe agency_id column works as the key that links the routes to the data described in agency.txt, listing an agency described in that file - in this case the agency with id 1 (SPTrans itself). This column is optional in the case of feeds containing a single agency, but is mandatory otherwise. Using a feed describing a multimodal system with a subway corridor and several bus lines as an example, a possible configuration of routes.txt could associate the subway routes to the subway operator and the bus routes to the agency/company responsible for planning the bus schedules.\nThe route_type column is used to describe the transport mode of each route. The above example lists rail lines, whose corresponding numeric value is 2. The corresponding values of other transport modes are listed in the specification.\n\n\n4.1.4 trips.txt\nFile used to describe the trips that compose the system. The trip is the basic unit of movement in the GTFS format: each trip is associated with a public transport route (route_id), with a service that operates on certain days of the week (as we will later cover in calendar.txt) and with a spatial trajectory (as we will later cover in shapes.txt). Table 4.4 shows the trips.txt of SPTrans’ feed.\n\n\n\n\nTable 4.4: trips.txt example\n\n\n\n\n\n\n\n\n\n\ntrip_id\nroute_id\nservice_id\ntrip_headsign\ndirection_id\nshape_id\n\n\n\n\nCPTM L07-0\nCPTM L07\nUSD\nJUNDIAI\n0\n17846\n\n\nCPTM L07-1\nCPTM L07\nUSD\nLUZ\n1\n17847\n\n\nCPTM L08-0\nCPTM L08\nUSD\nAMADOR BUENO\n0\n17848\n\n\nCPTM L08-1\nCPTM L08\nUSD\nJULIO PRESTES\n1\n17849\n\n\nCPTM L09-0\nCPTM L09\nUSD\nGRAJAU\n0\n17850\n\n\nCPTM L09-1\nCPTM L09\nUSD\nOSASCO\n1\n17851\n\n\n\n\n\n\nThe trip_id column identifies the trips described in the table, just as the route_id references a route described in routes.txt. The service_id column identifies the services that determine the days of the week that each trip runs on (weekdays, weekends, a mix of both, etc), described in detail in calendar.txt. The rightmost column in the example above is shape_id, which identifies the spatial trajectory of each trip, described in detail in shapes.txt.\nThe two remaining columns, trip_headsign and direction_id, are optional and should be used to describe the direction/destination of the trip. The first, trip_headsign, is used to report the text that appears on the vehicle headsign (in the case of buses, for example) or on information panels (such as on subway and rail stations) highlighting the destination of the trip. The direction_id column is often used in conjunction with trip_headsign to distinguish the direction of each trip, where 0 represents one direction and 1 the opposite (whether to use the value of 0 or 1 when describing a trip is up to the feed producer, as long as they represent opposite directions). In our example, the first two rows describe trips that refer to the same public transport route (CPTM L07), but in opposite directions: one runs towards Jundiaí, and the other towards Luz.\n\n\n4.1.5 calendar.txt\nFile used to describe the different types of service existing in the system. A service, in this context, denotes a set of days of the week in which trips may occur. Each service is also defined by an interval, with a start and an end date, within which it is valid. Table 4.5 shows the calendar.txt of SPTrans’ feed.\n\n\n\n\nTable 4.5: calendar.txt example\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nservice_id\nmonday\ntuesday\nwednesday\nthursday\nfriday\nsaturday\nsunday\nstart_date\nend_date\n\n\n\n\nUSD\n1\n1\n1\n1\n1\n1\n1\n20080101\n20200501\n\n\nU__\n1\n1\n1\n1\n1\n0\n0\n20080101\n20200501\n\n\nUS_\n1\n1\n1\n1\n1\n1\n0\n20080101\n20200501\n\n\n_SD\n0\n0\n0\n0\n0\n1\n1\n20080101\n20200501\n\n\n__D\n0\n0\n0\n0\n0\n0\n1\n20080101\n20200501\n\n\nS\n0\n0\n0\n0\n0\n1\n0\n20080101\n20200501\n\n\n\n\n\n\nThe column service_id identifies each service described in the table. As shown earlier, this identifier is also used in the trips.txt, where it is responsible for associating each trip to a particular service.\nThe monday, tuesday, wednesday, thursday, friday, saturday and sunday columns are used to set the days of the week in which each service operates. A value of 1 means that the service operates that day, while a value of 0 means that it does not operate. In the example above, the USD service operates every day of the week and the service U__ operates only on business days.\nFinally, the columns start_date and end_date delimit the service interval. Dates in GTFS files must always be formatted using the YYYYMMDD format: the first four numbers define the year, the subsequent two define the month and the last two, the day. The value 20220428, for example, represents April 28th 2022.\n\n\n4.1.6 shapes.txt\nFile used to describe the spatial trajectory of each trip in the system. This file is optional, but feed producers are strongly recommended to include it in their GTFS files. Table 4.6 shows the shapes.txt of SPTrans’ feed.\n\n\n\n\nTable 4.6: shapes.txt example\n\n\nshape_id\nshape_pt_lat\nshape_pt_lon\nshape_pt_sequence\n\n\n\n\n17846\n-23.53517\n-46.63535\n1\n\n\n17846\n-23.53513\n-46.63548\n2\n\n\n17846\n-23.53494\n-46.63626\n3\n\n\n17846\n-23.53473\n-46.63710\n4\n\n\n17846\n-23.53466\n-46.63735\n5\n\n\n17846\n-23.53416\n-46.63866\n6\n\n\n\n\n\n\nThe column shape_id identifies each shape, and it is responsible for associating each trip to its spatial trajectory in trips.txt. Unlike all the other identifiers we have seen so far, however, shape_id is repeated in several table rows. This is because each shape_id is defined by a sequence of spatial points, whose geographic coordinates are described with the shape_pt_lat and shape_pt_lon columns. The shape_pt_sequence column lists the sequence in which the points connect to form the shape - values listed in this column should increase along the path.\n\n\n4.1.7 stop_times.txt\nFile used to describe the timetable of each trip, including the arrival and departure time at each stop. How this table should be formatted depends on whether the GTFS file contains a frequencies.txt table or not, a detail that we will cover later. For now, we will look at the stop_times.txt of SPTrans’ feed, which also includes a frequencies.txt, in Table 4.7.\n\n\n\n\nTable 4.7: stop_times.txt example\n\n\ntrip_id\narrival_time\ndeparture_time\nstop_id\nstop_sequence\n\n\n\n\nCPTM L07-0\n04:00:00\n04:00:00\n18940\n1\n\n\nCPTM L07-0\n04:08:00\n04:08:00\n18920\n2\n\n\nCPTM L07-0\n04:16:00\n04:16:00\n18919\n3\n\n\nCPTM L07-0\n04:24:00\n04:24:00\n18917\n4\n\n\nCPTM L07-0\n04:32:00\n04:32:00\n18916\n5\n\n\nCPTM L07-0\n04:40:00\n04:40:00\n18965\n6\n\n\n\n\n\n\nThe trip whose timetable is being described is identified by trip_id. Similarly to what happens in shapes.txt, the same trip_id is found in many observations. This is because, just as a trajectory is composed of a sequence of spatial points, a timetable consists of a sequence of several departure/arrival times at various public transport stops.\nThe following columns, arrival_time, departure_time and stop_id, are responsible for describing the schedule of each trip, associating an arrival and a departure time at each visited stop. The time columns must be formatted using the HH:MM:SS format, with the first two numbers defining the hour, the subsequent two the minutes and the last two, the seconds. This format also accepts hour values greater than 24 - e.g. a trip whose last stop is visited at 1:00 a.m. the day after it departed from the first stop (let’s say it has departed at 11:00 p.m.) must fill the arrival time as 25:00:00, not 01:00:00. The stop_id column associates the arrival and departure times with a stop described in the stops.txt, and the stop_sequence column lists the sequence in which the stops connect to form the trip schedule. The values of this last column must always increase along the trip.\nIt is worth highlighting here the difference between shapes.txt and stop_times.txt. Although both tables describe a trip spatially, they do it in different ways. stop_times.txt lists the sequence of stops and times that make up a schedule, but says nothing about the trajectory traveled between the stops. shapes.txt, on the other hand, describes the detailed trajectory of a trip, but does not specify where the public transport stops are located. Combining the information from the two tables, therefore, allows us to know both the schedule of each trip and the spatial trajectory between stops.\n\n\n4.1.8 frequencies.txt\nOptional file used to describe the frequency of each trip within a certain time interval of a day. Table 4.8 shows the frequency.txt of SPTrans’ feed.\n\n\n\n\nTable 4.8: frequencies.txt example\n\n\ntrip_id\nstart_time\nend_time\nheadway_secs\n\n\n\n\nCPTM L07-0\n04:00:00\n04:59:00\n720\n\n\nCPTM L07-0\n05:00:00\n05:59:00\n360\n\n\nCPTM L07-0\n06:00:00\n06:59:00\n360\n\n\nCPTM L07-0\n07:00:00\n07:59:00\n360\n\n\nCPTM L07-0\n08:00:00\n08:59:00\n360\n\n\nCPTM L07-0\n09:00:00\n09:59:00\n480\n\n\n\n\n\n\nThe trip whose frequency is being described is identified by the trip_id column. Again, the same identifier may appear in multiple observations. This is because the specification allows the same trip to have different frequencies throughout the day, such as at rush and off-rush hours, for example. Each row describes an interval that starts at the time in start_time and ends at the time in end_time.\nWithin the time interval specified by these two columns, the trip operates on regular headways specified in headway_secs. The headway is the time between trips performed by the same route. This time must be specified in seconds. In the example above, a headway of 720 between 4 and 5 am, therefore, means that the CPTM L07-0 trip departs every 12 minutes within this interval.\nUsing frequencies.txt and stop_times.txt together\nIt is important to understand how the presence of a frequencies.txt table changes the specification of stop_times.txt. As we can see in the stop_times.txt example, the CPTM L07-0 trip departs from the first stop at 04:00 am and arrives at the second at 04:08 am. The arrival and departure times at a given stop, however, cannot be specified more than once for each trip, even though the headway set in frequencies.txt defines that this trip departs every 12 minutes from 4 am to 5 am. If that’s the case, how can we set the schedule of trips departing at 04:12 am, 04:24 am, 04:36 am, etc?\nIf the frequency of a trip is specified in frequencies.txt, the timetable of this trip defined in stop_times.txt should be understood as a reference that describes the time between stops. In other words, the times defined there should not be interpreted as is. For example, the timetable of trip CPTM L07-0 establishes that the journey between the first and second stop takes 8 minutes to complete, which is the same travel time between the second and third stops as well. Thus, a trip departing from the first stop at 04:00 am arrives at the second at 04:08 am and at the third at 04:16 am. The next trip, which on the other hand departs from the first stop at 04:12 am, arrives at the second stop at 04:20 am, and the third at 04:28 am.\nTo describe the same trips in stop_times.txt without making a frequencies.txt table, could add a suffix that would identify each trip of route CPTM L07 in direction 0 throughout the day. The trip with id CPTM L07-0_1, for example, would be the first trip 0 of the day heading towards direction 0 and it would depart from the first stop at 04:00 am and arrive at the second at 04:08 am. The CPTM L07-0_2 trip, on the other hand, would be the second trip of the day and would depart from the first stop at 04:12 am and arrive at the second at 04:20 am. The rest of the trips would follow the same pattern. Each one of these trips would also need to be added to trips.txt, as well as to any other tables that would refer to the trip_id.\nAnother variable that changes how frequencies.txt affects the timetables in stop_times.txt is the optional column exact_times. When it assumes the value of 0 (or when it is missing from the feed, as in the case of the SPTrans’ GTFS file) it indicates that the trip does not necessarily follow a fixed schedule over the time interval. Instead, operators try to maintain a predetermined headway during the interval. Using the same example of a trip whose headway is 12 minutes between 4:00 am and 5:00 am, this would mean that the first departure does not necessarily happen at 4:00 am, the second at 04:12 am, and so on. The first trip can, for example, leave at 4:02 am. The second, at 4:14 am or 4:13 am, etc. To define a schedule that is always followed with the exact same headway, obtaining the same result that would be obtained if we defined several similar trips departing at different times in stop_times.txt (as shown in the previous paragraph), we should use exact_times with value 1."
  },
  {
    "objectID": "4_dados_gtfs.en.html#finding-gtfs-data-for-brazilian-cities",
    "href": "4_dados_gtfs.en.html#finding-gtfs-data-for-brazilian-cities",
    "title": "4  GTFS data",
    "section": "4.2 Finding GTFS data for Brazilian cities",
    "text": "4.2 Finding GTFS data for Brazilian cities\nGTFS data from cities all over the world can be downloaded with the {tidytransit} R package or on the Transitland website. In Brazil, several cities use GTFS data to plan and operate their transport systems. In many cases, however, this data is owned by private companies and operators and may not be public. GTFS data in Brazil, consequently, is rarely openly and publicly available, which goes against public interest data management good practices. Table 4.9 lists some of the few cities that make their GTFS feeds openly available to the public4.\n\n\n\n\nTable 4.9: Openly available GTFS data in Brazil\n\n\nCity\nSource\nInfo\n\n\n\n\nBelo Horizonte\nBHTrans\nOpen data: conventional transport; supplementary transport.\n\n\nFortaleza\nETUFOR\nOpen data.\n\n\nFortaleza\nMetrofor\nOpen data.\n\n\nPorto Alegre\nEPTC\nOpen data.\n\n\nRio de Janeiro\nSMTR\nOpen data.\n\n\nSão Paulo\nEMTU\nDownload link. Registration required.\n\n\nSão Paulo\nSPTrans\nDownload link. Registration required.\n\n\n\n\n\n\nNote: The GTFS data provided by Rio de Janeiro Municipal Department of Transport (SMTR) does not include train and subway data.\n\n\n\n\nMcHugh, Bibiana. 2013. “Pioneering Open Data Standards: The GTFS Story.” In Beyond Transparency: Open Data and the Future of Civic Innovation, edited by Brett Goldstein and Lauren Dyson, First, 125–35. San Francisco, CA: Code for America Press.\n\n\nPereira, Rafael H. M., Pedro R. Andrade, and João Pedro Bazzo Vieira. 2022. “Exploring the Time Geography of Public Transport Networks with the Gtfs2gps Package.” SocArXiv. https://doi.org/10.31235/osf.io/qydr6."
  },
  {
    "objectID": "5_gtfstools.en.html#reading-and-manipulating-gtfs-files",
    "href": "5_gtfstools.en.html#reading-and-manipulating-gtfs-files",
    "title": "5  GTFS data manipulation and visualization",
    "section": "5.1 Reading and manipulating GTFS files",
    "text": "5.1 Reading and manipulating GTFS files\nReading GTFS files with {gtfstools} is done with the read_gtfs() function, which receives a string with the file path. The package represents a feed as a list of data.tables, a high-performance version of data.frames. Throughout this chapter, we will refer to this list of tables as a GTFS object. By default, the function reads all .txt tables in the feed:\n\n# loads the package\nlibrary(gtfstools)\n\n# points to the sample gtfs data installed in {gtfstools}\npath <- system.file(\"extdata/spo_gtfs.zip\", package = \"gtfstools\")\n\n# reads the gtfs\ngtfs <- read_gtfs(path)\n\n# checks the tables inside the gtfs object\nnames(gtfs)\n\n[1] \"agency\"      \"calendar\"    \"frequencies\" \"routes\"      \"shapes\"     \n[6] \"stop_times\"  \"stops\"       \"trips\"      \n\n\nWe can see that each data.table within the GTFS object is named according to the table it represents, without the .txt extension. This configuration allows us to select and manipulate each table individually. The code below, for example, lists the first 6 rows of the trips table:\n\nhead(gtfs$trips)\n\n   route_id service_id    trip_id trip_headsign direction_id shape_id\n1: CPTM L07        USD CPTM L07-0       JUNDIAI            0    17846\n2: CPTM L07        USD CPTM L07-1           LUZ            1    17847\n3: CPTM L08        USD CPTM L08-0  AMADOR BUENO            0    17848\n4: CPTM L08        USD CPTM L08-1 JULIO PRESTES            1    17849\n5: CPTM L09        USD CPTM L09-0        GRAJAU            0    17850\n6: CPTM L09        USD CPTM L09-1        OSASCO            1    17851\n\n\nTables within a GTFS object can be easily manipulated using the {data.table} package syntax. This package offers several useful features, primarily for manipulating tables with a large number of records, such as updating columns by reference, very fast row subsets and efficient data aggregation1. To add 100 seconds to all the headways listed in the frequencies table and to later reverse this change, for example, we can use the code below:\n\n# saves original headways\noriginal_headway <- gtfs$frequencies$headway_secs\nhead(gtfs$frequencies, 3)\n\n      trip_id start_time end_time headway_secs\n1: CPTM L07-0   04:00:00 04:59:00          720\n2: CPTM L07-0   05:00:00 05:59:00          360\n3: CPTM L07-0   06:00:00 06:59:00          360\n\n# updates the headways\ngtfs$frequencies[, headway_secs := headway_secs + 100]\nhead(gtfs$frequencies, 3)\n\n      trip_id start_time end_time headway_secs\n1: CPTM L07-0   04:00:00 04:59:00          820\n2: CPTM L07-0   05:00:00 05:59:00          460\n3: CPTM L07-0   06:00:00 06:59:00          460\n\n# restores the original headway\ngtfs$frequencies[, headway_secs := original_headway]\nhead(gtfs$frequencies, 3)\n\n      trip_id start_time end_time headway_secs\n1: CPTM L07-0   04:00:00 04:59:00          720\n2: CPTM L07-0   05:00:00 05:59:00          360\n3: CPTM L07-0   06:00:00 06:59:00          360\n\n\nAfter editing a GTFS object in R, we often want to use the processed GTFS to perform different analyses. In order to do this, we frequently need the GTFS file in .zip format again, and not as a list of tables in an R session. Looking to transform GTFS objects that exist only within R into GTFS files saved to disk, {gtfstools} includes the write_gtfs(). To use this function, we only need to list the object that should be written to disk and the file path where it should be written to:\n\n# points to the path where the GTFS should be written to\nexport_path <- tempfile(\"new_gtfs\", fileext = \".zip\")\n\n# writes the GTFS to the path\nwrite_gtfs(gtfs, path = export_path)\n\n# lists files within the feed\nzip::zip_list(export_path)[, c(\"filename\", \"compressed_size\", \"timestamp\")]\n\n         filename compressed_size           timestamp\n1      agency.txt             112 2023-02-14 20:56:16\n2    calendar.txt             129 2023-02-14 20:56:16\n3 frequencies.txt            2381 2023-02-14 20:56:16\n4      routes.txt             659 2023-02-14 20:56:16\n5      shapes.txt          160470 2023-02-14 20:56:16\n6  stop_times.txt            7907 2023-02-14 20:56:16\n7       stops.txt           18797 2023-02-14 20:56:16\n8       trips.txt             717 2023-02-14 20:56:16"
  },
  {
    "objectID": "5_gtfstools.en.html#calculating-trip-speed",
    "href": "5_gtfstools.en.html#calculating-trip-speed",
    "title": "5  GTFS data manipulation and visualization",
    "section": "5.2 Calculating trip speed",
    "text": "5.2 Calculating trip speed\nGTFS files are often used in public transport routing applications and to inform the timetable of different routes in a given region to potential passengers. Feeds must, therefore, accurately describe the schedule of public transport trips.\nAn useful way to validate the schedules described in the feed is to check the average speed of each trip. To do so, {gtfstools} includes the function get_trip_speed(). By default, the function returns the speed (in km/h) of all trips included in the feed, but one can choose to calculate the speed of selected trips with the trip_id parameter:\n\n# calculates the speeds of all trips\nspeeds <- get_trip_speed(gtfs)\n\nhead(speeds)\n\n     trip_id origin_file     speed\n1: 2002-10-0      shapes  8.952511\n2: 2105-10-0      shapes 10.253365\n3: 2105-10-1      shapes  9.795292\n4: 2161-10-0      shapes 11.182534\n5: 2161-10-1      shapes 11.784458\n6: 4491-10-0      shapes 13.203560\n\nnrow(speeds)\n\n[1] 36\n\n# calculates the speeds of two specific trips\nspeeds <- get_trip_speed(gtfs, trip_id = c(\"CPTM L07-0\", \"2002-10-0\"))\n\nhead(speeds)\n\n      trip_id origin_file     speed\n1:  2002-10-0      shapes  8.952511\n2: CPTM L07-0      shapes 26.787768\n\n\nTo calculate the speed of a trip we need to know its length and how long it takes to travel from its first to its last stop. Behind the scenes, get_trip_speed() uses two other functions from {gtfstools} toolset: get_trip_length() and get_trip_duration(). The usage of both is very similar to what has been shown before, returning the length/duration of all trips by default, or of a few specified trips if desired. Below, we show their default behavior:\n\n# calculates the length of all trips\nlengths <- get_trip_length(gtfs, file = \"shapes\")\n\nhead(lengths)\n\n      trip_id   length origin_file\n1: CPTM L07-0 60.71894      shapes\n2: CPTM L07-1 60.71894      shapes\n3: CPTM L08-0 41.79037      shapes\n4: CPTM L08-1 41.79037      shapes\n5: CPTM L09-0 31.88906      shapes\n6: CPTM L09-1 31.88906      shapes\n\n# calculates the duration of all trips\ndurations <- get_trip_duration(gtfs)\n\nhead(durations)\n\n     trip_id duration\n1: 2002-10-0       48\n2: 2105-10-0      108\n3: 2105-10-1      111\n4: 2161-10-0       94\n5: 2161-10-1       93\n6: 4491-10-0       69\n\n\nJust as get_trip_speed() returns speeds in km/h by default, get_trip_length() returns lengths in km and get_trip_duration() returns the duration in minutes. These units can be adjusted with the unit argument, present in all three functions."
  },
  {
    "objectID": "5_gtfstools.en.html#combining-and-filtering-feeds",
    "href": "5_gtfstools.en.html#combining-and-filtering-feeds",
    "title": "5  GTFS data manipulation and visualization",
    "section": "5.3 Combining and filtering feeds",
    "text": "5.3 Combining and filtering feeds\nThe tasks of processing and manipulating GTFS files are often performed manually. Consequently, minor inconsistencies can pass by those responsible for these tasks. A commonly observed issue is the presence of duplicate records in the same table. SPTrans’ feed, for example, contains duplicate records both in agency.txt and in calendar.txt:\n\ngtfs$agency\n\n   agency_id agency_name                               agency_url\n1:         1     SPTRANS http://www.sptrans.com.br/?versao=011019\n2:         1     SPTRANS http://www.sptrans.com.br/?versao=011019\n     agency_timezone agency_lang\n1: America/Sao_Paulo          pt\n2: America/Sao_Paulo          pt\n\ngtfs$calendar\n\n    service_id monday tuesday wednesday thursday friday saturday sunday\n 1:        USD      1       1         1        1      1        1      1\n 2:        U__      1       1         1        1      1        0      0\n 3:        US_      1       1         1        1      1        1      0\n 4:        _SD      0       0         0        0      0        1      1\n 5:        __D      0       0         0        0      0        0      1\n 6:        _S_      0       0         0        0      0        1      0\n 7:        USD      1       1         1        1      1        1      1\n 8:        U__      1       1         1        1      1        0      0\n 9:        US_      1       1         1        1      1        1      0\n10:        _SD      0       0         0        0      0        1      1\n11:        __D      0       0         0        0      0        0      1\n12:        _S_      0       0         0        0      0        1      0\n    start_date   end_date\n 1: 2008-01-01 2020-05-01\n 2: 2008-01-01 2020-05-01\n 3: 2008-01-01 2020-05-01\n 4: 2008-01-01 2020-05-01\n 5: 2008-01-01 2020-05-01\n 6: 2008-01-01 2020-05-01\n 7: 2008-01-01 2020-05-01\n 8: 2008-01-01 2020-05-01\n 9: 2008-01-01 2020-05-01\n10: 2008-01-01 2020-05-01\n11: 2008-01-01 2020-05-01\n12: 2008-01-01 2020-05-01\n\n\n{gtfstools} includes the remove_duplicates() function to keep only unique entries in the feed. This function takes a GTFS object as input and returns the same object without duplicate entries:\n\nno_dups_gtfs <- remove_duplicates(gtfs)\n\nno_dups_gtfs$agency\n\n   agency_id agency_name                               agency_url\n1:         1     SPTRANS http://www.sptrans.com.br/?versao=011019\n     agency_timezone agency_lang\n1: America/Sao_Paulo          pt\n\nno_dups_gtfs$calendar\n\n   service_id monday tuesday wednesday thursday friday saturday sunday\n1:        USD      1       1         1        1      1        1      1\n2:        U__      1       1         1        1      1        0      0\n3:        US_      1       1         1        1      1        1      0\n4:        _SD      0       0         0        0      0        1      1\n5:        __D      0       0         0        0      0        0      1\n6:        _S_      0       0         0        0      0        1      0\n   start_date   end_date\n1: 2008-01-01 2020-05-01\n2: 2008-01-01 2020-05-01\n3: 2008-01-01 2020-05-01\n4: 2008-01-01 2020-05-01\n5: 2008-01-01 2020-05-01\n6: 2008-01-01 2020-05-01\n\n\nWe often have to deal with multiple feeds describing the same study area - for example, when the bus and the rail systems of a single city are described in separate GTFS files. In such cases, we frequently benefit from merging both files into a single feed, reducing the data processing effort. To help us with that, {gtfstools} includes the merge_gtfs() function. The example below shows the output of merging SPtrans’ feed (without duplicate entries) with EPTC’s (Porto Alegre’s Transport and Traffic Public Company):\n\n# reads Porto Alegre's GTFS\npoa_path <- system.file(\"extdata/poa_gtfs.zip\", package = \"gtfstools\")\npoa_gtfs <- read_gtfs(poa_path)\n\npoa_gtfs$agency\n\n   agency_id                                 agency_name             agency_url\n1:      EPTC Empresa Publica de Transportes e Circulação http://www.eptc.com.br\n     agency_timezone agency_lang agency_phone\n1: America/Sao_Paulo          pt          156\n                                                  agency_fare_url\n1: http://www2.portoalegre.rs.gov.br/eptc/default.php?p_secao=155\n\nno_dups_gtfs$agency\n\n   agency_id agency_name                               agency_url\n1:         1     SPTRANS http://www.sptrans.com.br/?versao=011019\n     agency_timezone agency_lang\n1: America/Sao_Paulo          pt\n\n# combines Porto Alegre's and São Paulo's GTFS objects\ncombined_gtfs <- merge_gtfs(no_dups_gtfs, poa_gtfs)\n\n# checa resultados\ncombined_gtfs$agency\n\n   agency_id                                 agency_name\n1:         1                                     SPTRANS\n2:      EPTC Empresa Publica de Transportes e Circulação\n                                 agency_url   agency_timezone agency_lang\n1: http://www.sptrans.com.br/?versao=011019 America/Sao_Paulo          pt\n2:                   http://www.eptc.com.br America/Sao_Paulo          pt\n   agency_phone                                                agency_fare_url\n1:                                                                            \n2:          156 http://www2.portoalegre.rs.gov.br/eptc/default.php?p_secao=155\n\n\nWe can see that the tables of both feeds are combined into a single one. This is the case when two (or more, if desired) GTFS objects contain the same table (agency, in the example). When only one of the objects contains a given table, the function copies this table to the final result. That’s the case of the frequencies table, in our example, which exists only in SPTrans’ feed:\n\nnames(poa_gtfs)\n\n[1] \"agency\"     \"calendar\"   \"routes\"     \"shapes\"     \"stop_times\"\n[6] \"stops\"      \"trips\"     \n\nnames(no_dups_gtfs)\n\n[1] \"agency\"      \"calendar\"    \"frequencies\" \"routes\"      \"shapes\"     \n[6] \"stop_times\"  \"stops\"       \"trips\"      \n\nnames(combined_gtfs)\n\n[1] \"agency\"      \"calendar\"    \"frequencies\" \"routes\"      \"shapes\"     \n[6] \"stop_times\"  \"stops\"       \"trips\"      \n\nidentical(no_dups_gtfs$frequencies, combined_gtfs$frequencies)\n\n[1] TRUE\n\n\nAnother frequently used operation when dealing with GTFS files is filtering the data. Feeds are often used to describe large-scale public transport networks, which may result in complex and slow data manipulation, analysis and sharing. Thus, planners and researchers often work with a feed subset. If we want to measure the performance of a transport network during the morning peak, for example, we can filter our GTFS data to keep only the observations that relate to trips that happen within this period.\n{gtfstools} includes lots of functions to filter GTFS data. The currently available filtering functions are:\n\nfilter_by_agency_id()\nfilter_by_route_id()\nfilter_by_service_id()\nfilter_by_shape_id()\nfilter_by_stop_id()\nfilter_by_trip_id()\nfilter_by_route_type()\nfilter_by_weekday()\nfilter_by_time_of_day()\nfilter_by_sf()\n\nFiltering by identifiers\nThe six first function from the above list (filter_by_agency_id(), filter_by_route_id(), filter_by_service_id(), filter_by_shape_id(), filter_by_stop_id() e filter_by_trip_id()) work very similarly. They take as input a vector of identifiers and return a GTFS object whose table entries are related to the specified ids. The example below demonstrates the functionality with filter_by_trip_id():\n\n# checks pre-filter object size \nutils::object.size(gtfs)\n\n864568 bytes\n\nhead(gtfs$trips[, .(trip_id, trip_headsign, shape_id)])\n\n      trip_id trip_headsign shape_id\n1: CPTM L07-0       JUNDIAI    17846\n2: CPTM L07-1           LUZ    17847\n3: CPTM L08-0  AMADOR BUENO    17848\n4: CPTM L08-1 JULIO PRESTES    17849\n5: CPTM L09-0        GRAJAU    17850\n6: CPTM L09-1        OSASCO    17851\n\n# keeps entries related to the two specified ids\nfiltered_gtfs <- filter_by_trip_id(\n  gtfs,\n  trip_id = c(\"CPTM L07-0\", \"CPTM L07-1\")\n)\n\n# checks post-filter object size\nutils::object.size(filtered_gtfs)\n\n71592 bytes\n\nhead(filtered_gtfs$trips[, .(trip_id, trip_headsign, shape_id)])\n\n      trip_id trip_headsign shape_id\n1: CPTM L07-0       JUNDIAI    17846\n2: CPTM L07-1           LUZ    17847\n\nunique(filtered_gtfs$shapes$shape_id)\n\n[1] \"17846\" \"17847\"\n\n\nWe can see from the code snippet above that the function not only filters trips, but all other tables containing a column that relates to trip_id in any way. The shapes of trips CPTM L07-0 and CPTM L07-1, for example, are respectively described by shape_ids 17846 and 17847. Therefore, these are the only shape identifiers kept in the filtered GTFS.\nThe function also supports the opposite behavior: instead of keeping the entries related to the specified identifiers, we can drop them. To do this, we need to set the keep argument to FALSE:\n\n# removes entries related to two trips from the feed\nfiltered_gtfs <- filter_by_trip_id(\n  gtfs,\n  trip_id = c(\"CPTM L07-0\", \"CPTM L07-1\"),\n  keep = FALSE\n)\n\nhead(filtered_gtfs$trips[, .(trip_id, trip_headsign, shape_id)])\n\n      trip_id       trip_headsign shape_id\n1: CPTM L08-0        AMADOR BUENO    17848\n2: CPTM L08-1       JULIO PRESTES    17849\n3: CPTM L09-0              GRAJAU    17850\n4: CPTM L09-1              OSASCO    17851\n5: CPTM L10-0 RIO GRANDE DA SERRA    17852\n6: CPTM L10-1                BRÁS    17853\n\nhead(unique(filtered_gtfs$shapes$shape_id))\n\n[1] \"17848\" \"17849\" \"17850\" \"17851\" \"17852\" \"17853\"\n\n\nWe can see that the specified trips, as well as their shapes, are not present in the filtered GTFS. The same logic, demonstrated here with filter_by_trip_id(), applies to the functions that filter GTFS objects by agency_id, route_id, service_id, shape_id, stop_id and route_type.\nFiltering by day of the week and time of the day\nAnother recurrent operation when dealing with GTFS data is subsetting feeds to keep services that only happen during certain times of the day or days of the week. The package includes the filter_by_weekday() and filter_by_time_of_day() functions to be used for this.\nfilter_by_weekday() takes as input the days of the week whose services that operate on them should be kept (or dropped). The function also includes a combine parameter, which defines how multi-days filters work. When this argument receives the value \"and\", only services that operate on every single specified day are kept. When it receives the value \"or\", services that operate on at least one of the days are kept:\n\n# keeps services that operate on both on saturday AND sunday\nfiltered_gtfs <- filter_by_weekday(\n  no_dups_gtfs,\n  weekday = c(\"saturday\", \"sunday\"),\n  combine = \"and\"\n)\n\nfiltered_gtfs$calendar[, c(\"service_id\", \"sunday\", \"saturday\")]\n\n   service_id sunday saturday\n1:        USD      1        1\n2:        _SD      1        1\n\n# keeps services that operate EITHER on saturday OR on sunday\nfiltered_gtfs <- filter_by_weekday(\n  no_dups_gtfs,\n  weekday = c(\"sunday\", \"saturday\"),\n  combine = \"or\"\n)\n\nfiltered_gtfs$calendar[, c(\"service_id\", \"sunday\", \"saturday\")]\n\n   service_id sunday saturday\n1:        USD      1        1\n2:        US_      0        1\n3:        _SD      1        1\n4:        __D      1        0\n5:        _S_      0        1\n\n\nfilter_by_time_of_day(), on the other hand, takes the beginning and the end of a time window and keeps (or drops) the entries related to the trips that run within this window. The behavior of this function depends whether a frequencies table is included in the feed or not: the stop_times timetable of trips listed in frequencies must not be filtered, because, as previously mentioned, it works as a reference that describes the time between consecutive stops, and the departure and arrival times listed there should not be considered as is. If a trip is not listed in frequencies, however, its stop_times entries are filtered according to the specified time window. Let’s see how the function works with some examples:\n\n# keeps trips that run within the 5am to 6am window\nfiltered_gtfs <- filter_by_time_of_day(gtfs, from = \"05:00:00\", to = \"06:00:00\")\n\nhead(filtered_gtfs$frequencies)\n\n      trip_id start_time end_time headway_secs\n1: CPTM L07-0   05:00:00 05:59:00          360\n2: CPTM L07-1   05:00:00 05:59:00          360\n3: CPTM L08-0   05:00:00 05:59:00          480\n4: CPTM L08-1   05:00:00 05:59:00          480\n5: CPTM L09-0   05:00:00 05:59:00          480\n6: CPTM L09-1   05:00:00 05:59:00          480\n\nhead(filtered_gtfs$stop_times[, c(\"trip_id\", \"departure_time\", \"arrival_time\")])\n\n      trip_id departure_time arrival_time\n1: CPTM L07-0       04:00:00     04:00:00\n2: CPTM L07-0       04:08:00     04:08:00\n3: CPTM L07-0       04:16:00     04:16:00\n4: CPTM L07-0       04:24:00     04:24:00\n5: CPTM L07-0       04:32:00     04:32:00\n6: CPTM L07-0       04:40:00     04:40:00\n\n# salva a tabela frequencies e a remove do objeto gtfs\nfrequencies <- gtfs$frequencies\ngtfs$frequencies <- NULL\n\nfiltered_gtfs <- filter_by_time_of_day(gtfs, from = \"05:00:00\", to = \"06:00:00\")\n\nhead(filtered_gtfs$stop_times[, c(\"trip_id\", \"departure_time\", \"arrival_time\")])\n\n      trip_id departure_time arrival_time\n1: CPTM L07-0       05:04:00     05:04:00\n2: CPTM L07-0       05:12:00     05:12:00\n3: CPTM L07-0       05:20:00     05:20:00\n4: CPTM L07-0       05:28:00     05:28:00\n5: CPTM L07-0       05:36:00     05:36:00\n6: CPTM L07-0       05:44:00     05:44:00\n\n\nFiltering the stop_times table can work in two different ways. One is to keep entire trips that cross the specified time window. The other is to keep only the timetable entries that take place inside this window (default behavior). This behavior is controlled by the full_trips parameter, as shown below (please pay attention to the times and stops present in each example):\n\n# keeps any trips that cross the 5am to 6am window intact\nfiltered_gtfs <- filter_by_time_of_day(\n  gtfs,\n  from = \"05:00:00\", \n  to = \"06:00:00\",\n  full_trips = TRUE\n)\n\nhead(\n  filtered_gtfs$stop_times[\n    ,\n    c(\"trip_id\", \"departure_time\", \"arrival_time\", \"stop_sequence\")\n  ]\n)\n\n      trip_id departure_time arrival_time stop_sequence\n1: CPTM L07-0       04:00:00     04:00:00             1\n2: CPTM L07-0       04:08:00     04:08:00             2\n3: CPTM L07-0       04:16:00     04:16:00             3\n4: CPTM L07-0       04:24:00     04:24:00             4\n5: CPTM L07-0       04:32:00     04:32:00             5\n6: CPTM L07-0       04:40:00     04:40:00             6\n\n# keeps only the timetable entries that happen inside the 5am to 6am window\nfiltered_gtfs <- filter_by_time_of_day(\n  gtfs,\n  from = \"05:00:00\",\n  to = \"06:00:00\",\n  full_trips = FALSE\n)\n\nhead(\n  filtered_gtfs $stop_times[\n    ,\n    c(\"trip_id\", \"departure_time\", \"arrival_time\", \"stop_sequence\")\n  ]\n)\n\n      trip_id departure_time arrival_time stop_sequence\n1: CPTM L07-0       05:04:00     05:04:00             9\n2: CPTM L07-0       05:12:00     05:12:00            10\n3: CPTM L07-0       05:20:00     05:20:00            11\n4: CPTM L07-0       05:28:00     05:28:00            12\n5: CPTM L07-0       05:36:00     05:36:00            13\n6: CPTM L07-0       05:44:00     05:44:00            14\n\n\nFiltering using a spatial extent\nFinally, {gtfstools} also includes a function that allows us to filter a GTFS object using a spatial polygon. filter_by_sf() takes an sf/sfc object (spatial representation created by the {sf} package), or its bounding box, and keeps the entries related to trips that are selected by a specified spatial operation. Although seemingly complicated, this filtering process is fairly easy to grasp when shown. To demonstrate this function, we are going to filter SPTrans’ feed using the bounding box of shape 68962. With the code snippet below we show the spatial distribution of unfiltered data along with the bounding box in red:\n\nlibrary(ggplot2)\n\n# creates a polygon with the bounding box of shape 68962\nshape_68962 <- convert_shapes_to_sf(gtfs, shape_id = \"68962\")\nbbox <- sf::st_bbox(shape_68962)\nbbox_geometry <- sf::st_as_sfc(bbox)\n\n# creates a geometry with all the shapes described in the gtfs\nall_shapes <- convert_shapes_to_sf(gtfs)\n\nggplot() +\n  geom_sf(data = all_shapes) +\n  geom_sf(data = bbox_geometry, fill = NA, color = \"red\") +\n  theme_minimal()\n\n\n\n\nPlease note that we have used the convert_shapes_to_sf() function, also included in {gtfstools}, to convert the shapes described in the feed to a sf spatial object. By default, filter_by_sf() keeps all entries related to trips that intersect with the specified polygon:\n\nfiltered_gtfs <- filter_by_sf(gtfs, bbox)\nfiltered_shapes <- convert_shapes_to_sf(filtered_gtfs)\n\nggplot() +\n  geom_sf(data = filtered_shapes) +\n  geom_sf(data = bbox_geometry, fill = NA, color = \"red\") +\n  theme_minimal()\n\n\n\n\nWe can, however, specify the spatial operation used when filtering the feed. The code below shows how we can keep the entries related to trips that are contained by the specified polygon:\n\nfiltered_gtfs <- filter_by_sf(gtfs, bbox, spatial_operation = sf::st_contains)\nfiltered_shapes <- convert_shapes_to_sf(filtered_gtfs)\n\nggplot() +\n  geom_sf(data = filtered_shapes) +\n  geom_sf(data = bbox_geometry, fill = NA, color = \"red\") +\n  theme_minimal()"
  },
  {
    "objectID": "5_gtfstools.en.html#validating-gtfs-data",
    "href": "5_gtfstools.en.html#validating-gtfs-data",
    "title": "5  GTFS data manipulation and visualization",
    "section": "5.4 Validating GTFS data",
    "text": "5.4 Validating GTFS data\nTransport planners and researchers often want to assess the quality of the GTFS data which they are producing or using in their analyses. Are feeds structured according to the best practices adopted by the larger GTFS community? Are tables and columns adequately formatted? Is the information described by the feed reasonable (trip speeds, stop locations, etc)? These are some of the questions that may arise when dealing with GTFS data.\nTo answer these and other questions, {gtfstools} includes the validate_gtfs() function. This function works as a wrapper to MobilityData’s Canonical GTFS Validator. The validator requires Java version 11 or higher to run. For more information on how to check the installed version of Java in your computer and, if necessary, on how to install the required version, please check Chapter 3.\nUsing validate_gtfs() is very simple. First, we need to download the validator. To do this, we use the download_validator() function, included in the package, which receives the path to the directory where the validator should be saved to and the version of the validator that should be downloaded (defaults to the latest available). The function returns the path to the downloaded validator:\n\ntmpdir <- tempdir()\n\nvalidator_path <- download_validator(tmpdir)\nvalidator_path\n\n[1] \"/tmp/RtmpKJ2Oxn/gtfs-validator-v4.0.0.jar\"\n\n\nThe second (and final) step consists in actually validating the GTFS data with validate_gtfs(). This function supports GTFS data in different formats: (a) as a GTFS object in an R session, (b) as a path to a local GTFS file in .zip format, (c) as an URL pointing to a feed or (d) as a directory containing unzipped GTFS tables. The function also takes a path to a directory where the validation result should be saved to and the path to the validator that should be used in the process. In the example below we validate SPTrans’ feed from its path:\n\noutput_dir <- tempfile(\"gtfs_validation\")\n\nvalidate_gtfs(\n  path,\n  output_path = output_dir,\n  validator_path = validator_path\n)\n\nlist.files(output_dir)\n\n[1] \"report.html\"           \"report.json\"           \"system_errors.json\"   \n[4] \"validation_stderr.txt\"\n\n\nWe can see that the validation process generates a few output files:\n\nreport.html, shown in Figure 5.1, which summarizes the validation result in a nicely formatted HTML page (only available with validator version 3.1.0 or higher);\nreport.json, which summarizes the same information, but in JSON format, which can be used to programatically parse and process the results;\nsystem_errors.json, which summarizes eventual system errors that may have happened during the validation process and may compromise the results;\nvalidation_stderr.txt, which lists informative messages sent by the validator tool, including a list of the tests in use, eventual error messages, etc2.\n\n\n\n\n\n\nFigure 5.1: Validation report example"
  },
  {
    "objectID": "5_gtfstools.en.html#gtfstools-workflow-example-headways-spatial-visualization",
    "href": "5_gtfstools.en.html#gtfstools-workflow-example-headways-spatial-visualization",
    "title": "5  GTFS data manipulation and visualization",
    "section": "5.5 {gtfstools} workflow example: headways spatial visualization",
    "text": "5.5 {gtfstools} workflow example: headways spatial visualization\nWe have shown in previous sections that {gtfstools} offers a large toolset to process and analyze GTFS files. The package also includes many other functions that could not be shown in this book due to space constraints. The complete functions list can be checked at the package website.\nPresenting the functions as we have done up until this point is important to demonstrate how to use each one of them, but does not show how they can be used together when analyzing a feed. This section fills this gap, showing how the package can be used to answer the following question: how are the times between vehicles operating the same route (the headways) spatially distributed in SPTrans’ GTFS?\nFirst, we need to define the scope of our analysis. In this example, we are going to consider the morning peak headway, between 7am and 9am, on a typical tuesday. To do this, we need to filter our feed:\n\ngtfs <- read_gtfs(path)\n\n# filters the GTFS\nfiltered_gtfs <- gtfs |>\n  remove_duplicates() |>\n  filter_by_weekday(\"tuesday\") |>\n  filter_by_time_of_day(from = \"07:00:00\", to = \"09:00:00\")\n\n# cheking the result\n\nfiltered_gtfs$frequencies[trip_id == \"2105-10-0\"]\n\n     trip_id start_time end_time headway_secs\n1: 2105-10-0   07:00:00 07:59:00          900\n2: 2105-10-0   08:00:00 08:59:00         1200\n\nfiltered_gtfs$calendar\n\n   service_id monday tuesday wednesday thursday friday saturday sunday\n1:        USD      1       1         1        1      1        1      1\n2:        U__      1       1         1        1      1        0      0\n   start_date   end_date\n1: 2008-01-01 2020-05-01\n2: 2008-01-01 2020-05-01\n\n\nFollowing up, we need to calculate the headways within this time interval. This information can be found at the frequencies table, though there is a factor we have to pay attention to: each trip is associated to more than one headway, as shown above (one entry for the 7am to 7:59am interval and another for the 8am to 8:59am interval). To solve this we are going to calculate the average headway from 7am to 9am.\nThe first few frequencies rows in SPTrans’ feed seem to suggest that the headways are always associated to one-hour intervals, but this is neither a rule set in the official specification nor necessarily a practice adopted by other feed producers. Thus, we have to calculate the headways’ weighted mean within the morning peak, which we do by multiplying each headway by the time interval it is valid, summing the multiplication results for each trip and then dividing the total amount by the total time interval (two hours). To calculate the time intervals within which the headways are valid, we use the convert_time_to_seconds() function to calculate the interval start and end in seconds and subtract the latter by the former:\n\nfiltered_gtfs <- convert_time_to_seconds(filtered_gtfs)\n\nfiltered_gtfs$frequencies[trip_id == \"2105-10-0\"]\n\n     trip_id start_time end_time headway_secs start_time_secs end_time_secs\n1: 2105-10-0   07:00:00 07:59:00          900           25200         28740\n2: 2105-10-0   08:00:00 08:59:00         1200           28800         32340\n\nfiltered_gtfs$frequencies[, time_interval := end_time_secs - start_time_secs]\n\nThen we calculate the average headway:\n\naverage_headway <- filtered_gtfs$frequencies[,\n  .(average_headway = weighted.mean(x = headway_secs, w = time_interval)),\n  by = trip_id\n]\n\naverage_headway[trip_id == \"2105-10-0\"]\n\n     trip_id average_headway\n1: 2105-10-0            1050\n\nhead(average_headway)\n\n      trip_id average_headway\n1: CPTM L07-0             360\n2: CPTM L07-1             360\n3: CPTM L08-0             300\n4: CPTM L08-1             300\n5: CPTM L09-0             240\n6: CPTM L09-1             240\n\n\nNow we need to calculate each trip geometry to later join this data to the average headways. To do this, we will use the get_trip_geometry() function, which returns the spatial geometries of the trips in the feed. This function allows us to specify the trips which we want to calculate the geometries of, so we are only going to apply the procedure to those present in the average headways table:\n\nselected_trips <- average_headway$trip_id\n\ngeometries <- get_trip_geometry(\n  filtered_gtfs,\n  trip_id = selected_trips,\n  file = \"shapes\"\n)\n\nhead(geometries)\n\nSimple feature collection with 6 features and 2 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: -46.98404 ymin: -23.73644 xmax: -46.63535 ymax: -23.19474\nGeodetic CRS:  WGS 84\n     trip_id origin_file                       geometry\n1 CPTM L07-0      shapes LINESTRING (-46.63535 -23.5...\n2 CPTM L07-1      shapes LINESTRING (-46.87255 -23.1...\n3 CPTM L08-0      shapes LINESTRING (-46.64073 -23.5...\n4 CPTM L08-1      shapes LINESTRING (-46.98404 -23.5...\n5 CPTM L09-0      shapes LINESTRING (-46.77604 -23.5...\n6 CPTM L09-1      shapes LINESTRING (-46.69711 -23.7...\n\n\nFinally, we need to join the average headway data to the geometries. Having done so, the final step is only a matter of configuring the map as desired. In the example below, we use colors and lineweights that vary according to the headway of each trip:\n\ngeoms_with_headways <- merge(\n  geometries,\n  average_headway,\n  by = \"trip_id\"\n)\n\nggplot(geoms_with_headways) +\n  geom_sf(aes(color = average_headway, size = average_headway), alpha = 0.8) +\n  scale_color_gradient(high = \"#132B43\", low = \"#56B1F7\") +\n  theme_minimal()\n\n\n\n\nAs we can see, {gtfstools} turns analyzing GTFS feeds into a simple task that requires only basic knowledge of table manipulation packages (such as {data.table} and {dplyr}). The example shown in this section shows how many of the package’s functions can be used together to reveal important aspects of public transport systems specified in the GTFS format."
  },
  {
    "objectID": "s4_avaliacao_impacto.en.html",
    "href": "s4_avaliacao_impacto.en.html",
    "title": "Introdução à acessibilidade urbana",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "6_cenarios_transporte.en.html",
    "href": "6_cenarios_transporte.en.html",
    "title": "Introdução à acessibilidade urbana",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "s5_dados_aop.en.html",
    "href": "s5_dados_aop.en.html",
    "title": "Introdução à acessibilidade urbana",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "7_aopdata_populacao.en.html",
    "href": "7_aopdata_populacao.en.html",
    "title": "Introdução à acessibilidade urbana",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "8_aopdata_uso_solo.en.html",
    "href": "8_aopdata_uso_solo.en.html",
    "title": "Introdução à acessibilidade urbana",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "9_aopdata_acessibilidade.en.html",
    "href": "9_aopdata_acessibilidade.en.html",
    "title": "Introdução à acessibilidade urbana",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "references.en.html",
    "href": "references.en.html",
    "title": "Referências bibliográficas",
    "section": "",
    "text": "Boisjoly, Geneviève, and Ahmed M. El-Geneidy. 2017. “How to Get\nThere? A Critical Assessment of Accessibility Objectives\nand Indicators in Metropolitan Transportation Plans.”\nTransport Policy 55 (April): 38–50. https://doi.org/10.1016/j.tranpol.2016.12.011.\n\n\nBüttner, Benjamin. 2021. “Accessibility Tools for\nTransport Policy and Planning.” In\nInternational Encyclopedia of\nTransportation, edited by Roger Vickerman, 83–86.\nOxford: Elsevier. https://doi.org/10.1016/B978-0-08-102671-7.10618-9.\n\n\nLevine, Jonathan, Joe Grengs, and Louis A. Merlin. 2019. From\nMobility to Accessibility: Transforming Urban\nTransportation and Land-Use Planning. Cornell University\nPress.\n\n\nLevinson, David, and David King. 2020. Transport Access Manual:\nA Guide for Measuring Connection Between People and\nPlaces. Committee of the Transport Access Manual, University\nof Sydney.\n\n\nMcHugh, Bibiana. 2013. “Pioneering Open Data\nStandards: The GTFS Story.” In Beyond\nTransparency: Open Data and the\nFuture of Civic Innovation, edited by\nBrett Goldstein and Lauren Dyson, First, 125–35. San Francisco,\nCA: Code for America Press.\n\n\nMiller, Eric J. 2018. “Accessibility: Measurement and Application\nin Transportation Planning.” Transport Reviews 38 (5):\n551–55. https://doi.org/10.1080/01441647.2018.1492778.\n\n\nPapa, Enrica, Cecilia Silva, Marco Te Brömmelstroet, and Angela Hull.\n2015. “Accessibility Instruments for Planning Practice: A Review\nof European Experiences.” Journal of Transport\nand Land Use, June. https://doi.org/10.5198/jtlu.2015.585.\n\n\nPereira, Rafael H. M., Pedro R. Andrade, and João Pedro Bazzo Vieira.\n2022. “Exploring the Time Geography of Public Transport Networks\nwith the Gtfs2gps Package.” SocArXiv. https://doi.org/10.31235/osf.io/qydr6.\n\n\nSilva, Cecília, Luca Bertolini, Marco te Brömmelstroet, Dimitris\nMilakis, and Enrica Papa. 2017. “Accessibility Instruments in\nPlanning Practice: Bridging the Implementation Gap.”\nTransport Policy 53 (January): 135–45. https://doi.org/10.1016/j.tranpol.2016.09.006.\n\n\nvan Wee, Bert. 2021. “Transport Modes and\nAccessibility.” In International\nEncyclopedia of Transportation, edited by\nRoger Vickerman, 32–37. Oxford: Elsevier. https://doi.org/10.1016/B978-0-08-102671-7.10402-6."
  }
]